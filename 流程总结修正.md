# 流程总结修正

## 你的总结（基本正确，但需要澄清）

### ✅ 正确的部分

1. **"每个 MinerU 输出块对应一个 section，每个 section 对应一个 bbox"**
   - ✅ 正确：一对一映射关系

2. **"bbox通过parser.py的末尾_invoke()函数，变为JSON输出"**
   - ✅ 正确：图片上传步骤在 `_invoke()` 中

3. **"合并发生在两个阶段：attach_media_context() 和 naive_merge_with_images()"**
   - ✅ 正确：两个阶段都存在

4. **"若当前 chunk 为空，或 token 数超过限制，则需要创建新 chunk"**
   - ✅ 正确：这是核心判断条件

---

## ⚠️ 需要澄清和修正的部分

### 1. Section 和 Bbox 的详细说明

**你的描述：** "每个 section 对应一个 bbox，其中存储的是位置信息，用于后续裁剪图片"

**需要澄清：**
- **Section** 是 `(文本内容, 位置标签字符串)` 的元组
- **Bbox** 是包含 `{text, image, positions}` 的字典
- **图片裁剪发生在 bbox 创建时**，不是在后续步骤
  - 在 `parser.py:298` 中，`pdf_parser.crop(poss, 1)` 已经根据位置标签裁剪了图片
  - 所以 bbox 中的 `image` 字段已经是裁剪好的 PIL.Image 对象

**更准确的描述：**
```
Section (文本, 位置标签) 
    ↓
Bbox {text, image(已裁剪), positions}
    ↓
图片上传，image → img_id
    ↓
JSON {text, img_id, position_tag, positions}
```

### 2. Splitter 的调用流程

**你的描述：** "再通过splitter.py调用"

**需要澄清：**
- `splitter.py` 不是直接"调用"，而是：
  1. **从 JSON 中提取** sections 和 images（第 111-115 行）
  2. **调用** `naive_merge_with_images()` 进行合并（第 117 行）

**更准确的描述：**
```
JSON 输出
    ↓
splitter.py 提取 sections 和 images
    ↓
调用 naive_merge_with_images() 合并
```

### 3. attach_media_context() 的执行条件

**你的描述：** "功能是根据前后相邻的文本块，为图片和表格块添加上下文文本。但这个阶段不会合并 section，只是修改每个 bbox 的内容"

**需要澄清：**
- ✅ 功能描述正确
- ⚠️ **但默认情况下不执行**！
  - 只有当 `image_context_size > 0` 或 `table_context_size > 0` 时才会执行
  - 默认这两个值都是 0，所以**通常不会执行这个阶段**

**更准确的描述：**
```
attach_media_context() 是可选阶段：
- 默认不执行（image_context_size = 0, table_context_size = 0）
- 如果配置了上下文大小，才会为图片/表格块添加上下文
- 不会合并 section，只修改内容
```

### 4. 函数名称修正

**你的描述：** "核心合并规则是add_chunks()函数"

**需要修正：**
- ❌ 函数名是 `add_chunk()`（**单数**），不是 `add_chunks()`（复数）
- 它是 `naive_merge_with_images()` 内部的**辅助函数**（不是独立函数）

**更准确的描述：**
```
naive_merge_with_images() 函数内部：
    - 定义了一个内部辅助函数 add_chunk()（单数）
    - add_chunk() 实现了核心合并逻辑
```

### 5. 判断条件的详细说明

**你的描述：** "若当前 chunk 为空，或 token 数超过限制，则需要创建新 chunk"

**需要补充：**
- ✅ 判断条件正确
- ⚠️ 但需要说明"限制"的具体计算方式

**更准确的描述：**
```python
判断条件：
if 当前chunk为空 or 当前chunk的token数 > chunk_token_num * (100 - overlapped_percent)/100:
    创建新 chunk
else:
    合并到当前 chunk
```

**示例：**
- `chunk_token_num = 128`, `overlapped_percent = 0` → 限制 = 128
- `chunk_token_num = 128`, `overlapped_percent = 10` → 限制 = 115.2
- `chunk_token_num = 0` → 限制 = 0，但判断条件可能不满足，导致继续合并

---

## 📝 修正后的完整流程

### 阶段 1：Section → Bbox（一对一）

**位置：** `rag/flow/parser/parser.py:294-302`

```python
# MinerU 返回 sections: [(文本, 位置标签), ...]
for t, poss in lines:
    box = {
        "image": pdf_parser.crop(poss, 1),  # 根据位置标签裁剪图片（此时已裁剪）
        "positions": [[页码, x0, x1, top, bottom], ...],
        "text": t,
    }
    bboxes.append(box)  # 一对一映射
```

### 阶段 2：Bbox → JSON（图片上传）

**位置：** `rag/flow/parser/parser.py:882-887`

```python
# 图片上传到对象存储，PIL.Image → img_id
async with trio.open_nursery() as nursery:
    for d in outs.get("json", []):
        nursery.start_soon(image2id, d, ...)  # 上传并替换为 img_id
```

### 阶段 3：JSON → Sections（提取）

**位置：** `rag/flow/splitter/splitter.py:111-115`

```python
# 从 JSON 提取 sections 和 images
for o in json_result:
    sections.append((o.get("text", ""), o.get("position_tag", "")))
    section_images.append(id2image(o.get("img_id"), ...))  # img_id → PIL.Image
```

### 阶段 4（可选）：上下文添加

**位置：** `rag/nlp/__init__.py:361-547`  
**函数：** `attach_media_context()`

```python
# 默认不执行（image_context_size = 0, table_context_size = 0）
# 如果配置了上下文大小，为图片/表格块添加上下文
if table_ctx or image_ctx:
    bboxes = attach_media_context(bboxes, table_ctx, image_ctx)
```

### 阶段 5：Sections → Chunks（合并）

**位置：** `rag/nlp/__init__.py:922-1050`  
**函数：** `naive_merge_with_images()`

```python
# 内部辅助函数 add_chunk()（单数）
def add_chunk(t, image, pos=""):
    tnum = num_tokens_from_string(t)
    
    # 判断条件
    if cks[-1] == "" or tk_nums[-1] > chunk_token_num * (100 - overlapped_percent)/100.:
        # 创建新 chunk
        cks.append(t)
        result_images.append(image)
    else:
        # 合并到当前 chunk
        cks[-1] += t  # 文本追加
        result_images[-1] = concat_img(result_images[-1], image)  # 图片拼接
```

---

## ✅ 最终总结（修正版）

1. **MinerU 输出块 → Section → Bbox（一对一）**
   - Section 是 `(文本, 位置标签)` 元组
   - Bbox 是 `{text, image(已裁剪), positions}` 字典
   - 图片在 bbox 创建时已经根据位置标签裁剪完成

2. **Bbox → JSON（图片上传）**
   - 通过 `parser.py` 的 `_invoke()` 函数
   - PIL.Image 对象上传到对象存储，替换为 `img_id`

3. **JSON → Sections（提取）**
   - 通过 `splitter.py` 从 JSON 中提取
   - 每个 bbox 对应一个 section 和一个 image

4. **合并阶段（两个，但第一个默认不执行）**
   - **阶段 1（可选）：** `attach_media_context()` - 为图片/表格块添加上下文，默认不执行
   - **阶段 2（主要）：** `naive_merge_with_images()` - 将多个 sections 合并成 chunks

5. **核心合并规则**
   - 在 `naive_merge_with_images()` 内部的 `add_chunk()` 函数（**单数**）中实现
   - 判断条件：`当前chunk为空 or 当前chunk的token数 > chunk_token_num * (100 - overlapped_percent)/100`
   - 如果条件满足，创建新 chunk；否则合并到当前 chunk

---

## 🎯 关键修正点

1. ✅ 函数名：`add_chunk()`（单数），不是 `add_chunks()`
2. ✅ 图片裁剪：发生在 bbox 创建时，不是后续步骤
3. ✅ `attach_media_context()`：默认不执行，需要配置才会执行
4. ✅ Splitter 流程：先提取 sections，再调用合并函数
5. ✅ 判断条件：需要说明具体的计算方式

